package com.sist.main;
/*
 * 자바의 단어(개념 => 기술면접) ==>구현
 * =>웹(유선이 발전), 모바일
 *   ===========CURD
 * => 객체지향 프로그램
 *    1. 캡슐화 : 데이터 보호를 목적으로한다. 경계를 만들어준다.
 *    2. 상속/포함
 *    3. 다형성(오버로딩, 오버라이딩)
 *    4. 클래스의 종류
 *       = 일반클래스            Create,Update,Read,Delete
 *         =기능(메소드) ==>CURD(추가,수정,읽기,삭제)
 *          ~DAO, ~Manager(크롤링, XML, JSON)~Service
 *         =데이터만 관리하는 클래스(사용자 정의 데이터형)
 *          ~VO,~DTO
 *         =프로그램(데이터 수집,데이터 관리,데이터 처리)
 *       = 추상클래스
 *       = 인터페이스 (스프링은 인터페이스 기반)
 *       = 내부클래스 : 서로 다른 클래스가 공유하는 데이터가 많은 사용
 *                  => 쓰레드, 윈도우(애플리케이션)
 *                     ====(서버프로그램 => 웹서버 존재)
 *                  =>상속없이 오버라이딩 : 익명의 클래
 *         게시판 : 목록,상세보기,추가,수정,삭제
 *           |
 *         묻고답하기,  자료실,     후기게시판,   댓글형게시판
 *         =>답변     =>파일업로드. =>파일업로드  =>댓글
 *                     파일다운로드
 *         버튼 => 인터페이스(기능설계 => 프로그래머에게 전담)
 *         
 *         1. 캡슐화
 *            =은닉화 : private => 멤버변수 private, 메소드(다른 클래스와 연결) public
 *         2. 상속 => 확장해서 새로운 클래스를 만든다.
 *                   단일상속 => extends
 *                   classA
 *                   classB extends A => 재사용
 *                          =======
 *                          B는 A이다.
 *                   포함 : 라이브러리(있는 그대로 사용)
 *         3. 다형성 => 추가, 수정
 *            추가:오버로딩
 *            수정:오버라이딩(오버라이딩이 더 많은 이유는 자바가 미국에서 만들어졌고 우리나라와 실정이 맞지않음)
 *                => 한글변환
 *            ===========================================================
 *            클래스의 종류
 *            =>추상클래스 : 클래스들의 공통점을 뽑아서 만듦
 *              abstract class A => 선언(구현이 되지않은 설계) =>미완성클래스
 *              ========================================>완성해서 사용
 *            =>인터페이스 : 추상클래스의 일종        생               략
 *                       변수 =>상수형 변수를 사용 (public static fianl) int a = 10;
 *                       메소드 =>설계  (public abstract) void display(); 
 *                       JDK 1.8 변셩 : 구현된 메소드가 사용이 가능
 *              1. 독립적으로 사용이 가능
 *              2. 서로 다른 클래스를 연결해준다.(관련된 클래스 여러개를 묶어서 사용이 가능)
 *                 데이터가 여러개이면 (이름 한개로 관리를 해줌 => 배열)
 *                 클래스가 여러개이면 (인터페이스로 묶어서 관리)
 *              3. 표준화 작업할때 주로 사용
 *                 ==== 모든 개발자가 동일하게 사용, 프레임워크(프로그램통일화:스프링,마이바티스)
 *                 형식이 동일 =>분석
 *              4. 추상클래스를 보완 => 다중구현이 가능(상속)
 *                 
 *                 interface 비행
 *                 interface 배
 *                 interface 자동차 extends 비행기, 배
 *                 
 *                 interface ==> interface
 *                         extends
 *                 interface ==> class
 *                       implements------->오버라이딩
 *                                 ------->윈도우/쓰레드
 *                                 ------->컬렉션(인터페이스)
 *                 class ==> interface (존재하지않음)
 *               
 *               내부클래스 : 상속없이 오버라이딩이 가능, 서로 다른 클래스에서 데이터를 공유 
 *                                              ========================== static
 *               == 데이터 공유 : 멤버클래스
 *                  class A(웬도우,서버) {
 *                     =====
 *                     데이터
 *                     =====
 *                     class B(쓰레드) => 통
 *                     {
 *                     A가 가진 모든 데이터를 마음대로 B가 사용이 가능
 *                      }
 *                  }   
 *               == 상속없이 오버라이딩 : 익명의 클래스를 이용.
 *                  class A {
 *                  }
 *                  class B {
 *                     public void display(){}
 *                  }
 *                  
 *                  => class A extends B{
 *                         public void display(){내용변경}
 *                     }
 *                     class A {
 *                        B b = new B(){
 *                           public void display(){내용변경} : 오버라이딩
 *                           추가도 가능
 *                        }
 *                     }   
 *                ***** 웹은 상속, 인터페이스 구현(X)
 *                      =>Object (모든 클래스의 상위클래스)
 *                      => 형변환 (클래스->is a(상속), has a(포함))
 *                      class A{
 *                         int a,b,c,d,e,f,g; // 28byte
 *                      }
 *                      class B{
 *                         int a,b; // 8byte
 *                      }
 *                      실제 클래스크기는 동일하다(저장되는것은 주소값이 저장되는데 주소값은 int범위 내에서만 사용)
 *                      class A{
 *                      //실제 크기는 A가 크다
 *                      }
 *                      class B extends A{
 *                      //메모리는 B가 크다
 *                      }
 *                      A > B => 상속을 내리는 클래스가 크다.
 *                      => 객체생성
 *                         A a = new A();  => double a = 10.5
 *                         B b = new B();  => int b = 10
 *                         A c = new B();  => double c = 10
 *                         B d = new A();  => int d = (int)10.5
 *                              
 */
public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
